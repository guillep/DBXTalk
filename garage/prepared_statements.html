<!DOCTYPE html>
<html lang="en">
	<head>
    <meta charset='utf-8'>
    <title>Using Statement Objects</title>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="/DBXTalk/stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/DBXTalk/stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/DBXTalk/stylesheets/print.css" media="print">
	<script src="/DBXTalk/highlight/highlight.pack.js"></script>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  
  <body>
    <div class="container">
    	<div class="inner">
    	<header>
		  <img src="/DBXTalk/images/dbxtalk.png" style="height:100px;float:left; margin-right: 10px" />
          <h1>dbxtalk</h1>
          <h2>Pharo Relational Database Suite</h2>
        </header>
    	
    		<section id="downloads" class="clearfix">
          <a href="www.smalltalkhub.com/#!/~DBXTalk/Garage" id="view-on-sthub" class="button"><span>View on StHub</span></a>
		  <a href="installation.html" id="download-zip" class="button"><span>Download</span></a>
          <a href="https://ci.inria.fr/dbxtalk/view/Garage/" id="view-jenkins" class="button"><span>View on Jenkins</span></a>
          
        </section>

        <hr>

        <section id="main_content">
      	
<h2>1. Statement Objects</h2><a id="Statement Objects"></a>
<p>Statement objects support fine-grained control over statements sent to a database. We can create a statement object by sending the <strong>createStatement:</strong> message to a connection object with a SQL statement string, or the <strong>createStatement</strong> and then configuring the statement with the <strong>statementString:</strong> message.</p>
<p><figure><pre><code class="Smalltalk">aStatement := connection createStatement: 'CREATE TABLE CATS (
	name varchar(50),
	owner varchar(50))'.

anotherStatement := connection createStatement.
anotherStatement statementString: 'SELECT * FROM CATS'.</code></pre><figcaption></figcaption></figure></p>
<p>Statement objects can be executed sending them the <strong>execute</strong> message. Executing a statement returns the same kind of results as using the <strong>execute:</strong> message from a connection object. In fact, the connection object uses a statement object underneath.</p>
<p><figure><pre><code class="Smalltalk">result := aStatement execute.
result do: [ ... ].</code></pre><figcaption></figcaption></figure></p>
<p>Statement objects can be reused. We can send them multiple times the <strong>execute</strong> message and obtain our results multiple times. This is particularly useful to avoid statements with complex creations or already optimized by the database, as we will see later on.</p>
<p><figure><pre><code class="Smalltalk">result := aStatement execute.
result do: [ ... ].

&quot;we can execute it again and obtain the same results&quot;
aStatement execute do: [ ... ].</code></pre><figcaption></figcaption></figure></p>

<h2>2. Prepared Statements</h2><a id="Prepared Statements"></a>
<p>Some drivers support <strong>prepared</strong> statements. A prepared statement is a statement that is sent to the database to pre-process it. The database server can pre-parse it, cache results or even pre-calculate how it will execute the query. A prepared statement can be created by sending the <strong>prepare:</strong> message to a connection with a SQL statement string, or by sending the <strong>prepare</strong> message to an already existing statement.</p>
<p><figure><pre><code class="Smalltalk">preparedStatement := connection prepare: 'SELECT * FROM CATS'.

anotherPreparedStatement := aStatement createStatement: 'SELECT * FROM CATS'.
anotherPreparedStatement prepare.</code></pre><figcaption></figcaption></figure></p>
<p>Although prepared statements benefits, they are not equally supported by every database nor driver. Different databases support the preparation of different kind of statements, and not all database drivers support prepared statements. When a database driver supports prepared statements, the statement is sent to the database for its preparation immediately after the <strong>prepare</strong> message. If the sent statement cannot be prepared by the database, an exception will be thrown notifying it. If a database driver does not support prepared statements, the preparation will also fail with an exception. To know if a driver supports prepared statements, we can send the message <strong>supportsPreparedStatements</strong> to a database connection.</p>
<p><figure><pre><code class="Smalltalk">aConnection supportsPreparedStatements
	ifTrue: [ ... ]
	ifFalse: [ ... ]</code></pre><figcaption></figcaption></figure></p>
<p class="todo"><strong>TODO:</strong> provide a table with the drivers that support it. Also table of what kind of statements can be prepared by database</p><p class="todo">ask the database which kind of statements it supports for preparation</p>
<h4>2.0.1. Sanitizing SQL</h4><a id="Sanitizing SQL"></a>
<p>Composing strings to create a SQL statement can be cumbersome but also an unsafe way of creating a query. Attackers may benefit from wrongly sanitized SQL to perform SQL injection: the injection of SQL attacks inside a query. For example, considering the following SELECT query</p>
<p><figure><pre><code class="SQL">SELECT * FROM TABLE WHERE name=&lt;some param&gt;</code></pre><figcaption></figcaption></figure></p>
<p>If we naively concatenate it with the string we receive as an argument from a user, the user could be able to inject a DROP TABLE script like this:</p>
<p><figure><pre><code class="SQL">SELECT * FROM CATS WHERE name='';DROP TABLE CATS;</code></pre><figcaption></figcaption></figure></p>
<p>Prepared statements provide means to safely insert parameters inside a SQL statement. These parameters or placeholders are denoted inside a query by different literals, depending on the database server. It is the work of the database and its driver to safely replace the placeholder by its correct value and handle the escaping of such code to avoid injection.</p>
<ul><li> Question mark placeholders (<strong>?</strong>) are positional placeholders. Their index is their order of appearance.</li><li> Numbered placeholders are identified by a question mark or a dollar sign followed by an integer number (<strong>?1</strong>, <strong>?2</strong>, <strong>$1</strong>, <strong>$2</strong>). Their index is the number associated to them.</li><li> Named placeholders are identified by a dollar sign, an at sign or a collon followed by an name number (<strong>$name</strong>, <strong>@name</strong>, <strong>:name</strong>). Their index is the number associated to them. Usually, two named placeholders with the same name need to be set only once as they denote the same value.</li></ul>
<p><figure><pre><code class="Smalltalk">SELECT * FROM TABLE WHERE name='?'
SELECT * FROM TABLE WHERE name='$1'
SELECT * FROM TABLE WHERE name=':name'</code></pre><figcaption></figcaption></figure></p>
<p>The DBXTalk driver, by pursuing a common interface between different database drivers, only proposes question mark placeholders (<strong>?</strong>) in a SQL statement.</p>
<p>A statement placeholders can be filled with arguments using the <strong>at:bind:</strong> message. The <strong>at:bind:</strong> message accepts as argument any Pharo object and will transform it accordingly to its database representation. If no bind is specified, it is responsability of the driver to decide what to do. For example, SQLite3 will interpret missing bindings as <strong>NULL</strong>.</p>
<p class="todo"><strong>TODO:</strong> provide a table with these defaults.</p>
<p><figure><pre><code class="Smalltalk">statement := connection prepare: 'SELECT * FROM CATS WHERE name='?''.
statement at: 1 bind: 'lutz'.
result := statement execute</code></pre><figcaption></figcaption></figure></p>
<p>If we try to do SQL injection using placeholder bindings, it will escape the argument creating a safe version of the SQL statement. In this case the injected code will be embedded inside a string and the query will execute safely.</p>
<p><figure><pre><code class="Smalltalk">statement := connection prepare: 'SELECT * FROM CATS WHERE name='?''.
statement at: 1 bind: ''''';DROP TABLE TABLE;'.
result := statement execute.</code></pre><figcaption></figcaption></figure></p>
<p><figure><pre><code class="SQL">SELECT * FROM CATS WHERE name=''';DROP TABLE TABLE;'</code></pre><figcaption></figcaption></figure></p>
<p>A SQL statement can also contain many placeholders. In that case, the supplied bindings are set in order:</p>
<p><figure><pre><code class="Smalltalk">statement := connection prepare: 'SELECT * FROM CATS WHERE name='?' OR owner='?''.
statement at: 1 bind: 'lutz'.
statement at: 2 bind: 'guille'.
result := statement execute.</code></pre><figcaption></figcaption></figure></p>
<p><figure><pre><code class="Smalltalk">SELECT * FROM CATS WHERE name='lutz' OR owner='guille'</code></pre><figcaption></figcaption></figure></p>
      	</section>
		<footer>
          Dbxtalk is maintained by <a href="https://github.com/guillep">guillep</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>
      </div>
    </div>

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
  </body>
</html>
