<html><head><title>FLWordObjectCluster</title><link rel="stylesheet" type="text/css" href="../files/common.css"/><link rel="stylesheet" type="text/css" href="../files/stcode.css"/><link rel="stylesheet" type="text/css" href="../files/style.css"/><link rel="stylesheet" type="text/css" href="../files/vtip.css"/><script>/*<![CDATA[*/
document.WEBDOC_RELATIVE_DOCUMENT_ROOT ="../..";
document.WEBDOC_PHARO_VERSION ="'4.0'";
/*]]>*/</script><script src="../files/jQuery.js"></script><script src="../files/jQueryUi.js"></script><script src="../files/app.js"></script></head><body onload="onLoad()"><div id="header"><form accept-charset="utf-8" method="get" action="/" class="hidden" id="search"><div class="searchInput">Search: <input accesskey="s" placeholder="search" name="4" id="search_box" size="30" value="" onkeyup="$.ajax({&quot;url&quot;:&quot;/&quot;,&quot;data&quot;:[&quot;1&quot;,&quot;2=&quot;+encodeURIComponent($(&quot;#search_box&quot;).val())].join(&quot;&amp;&quot;)});$(&quot;#searchResults&quot;).load(&quot;/&quot;,&quot;3&quot;)" type="search" class="search"/></div><div id="searchResults"></div><div></div></form></div><div id="content"><h1 class="className">FLWordObjectCluster</h1><dl class="box"><dt>Subclass of: </dt><dd><span class="inheritName"><a class="object_link class_link" target="classView" title="FLBitsObjectCluster (class)" href="../class/FLBitsObjectCluster.html">FLBitsObjectCluster</a></span><ul class="fullTree"><li><a class="object_link class_link" target="classView" title="FLWordObjectCluster (class)" href="../class/FLWordObjectCluster.html">FLWordObjectCluster</a></li><li class="next"><a class="object_link class_link" target="classView" title="ProtoObject (class)" href="../class/ProtoObject.html">ProtoObject</a></li><li class="next"><a class="object_link class_link" target="classView" title="Object (class)" href="../class/Object.html">Object</a></li><li class="next"><a class="object_link class_link" target="classView" title="FLCluster (class)" href="../class/FLCluster.html">FLCluster</a></li><li class="next"><a class="object_link class_link" target="classView" title="FLIteratingCluster (class)" href="../class/FLIteratingCluster.html">FLIteratingCluster</a></li><li class="next"><a class="object_link class_link" target="classView" title="FLObjectCluster (class)" href="../class/FLObjectCluster.html">FLObjectCluster</a></li><li class="next"><a class="object_link class_link" target="classView" title="FLBitsObjectCluster (class)" href="../class/FLBitsObjectCluster.html">FLBitsObjectCluster</a></li></ul><a class="inheritanceTree">&oplus;</a></dd></dl><br/><div class="classComment"><h2 class="title">Overview</h2><div class="docString"><p>I am the generic cluster for storing and loading variable word objects. Most word-like objects are subclasses from <a class="stClassLiteral" href="class/FLWordObjectCluster.html/class/ArrayedCollection.html">ArrayedCollection</a>. Hence, we may have used the method #writeOn: to serialize, and #newFromStream: to materialize. </p><h3>writeOn: is slow because it ALWAYS encode wors in a big endian format. Most machines today are even little endian. Even worst, #newFromStream: has to always do a #restoreEndianness. </h3><h3>newFromStream: is fast because it uses the method #nextWordsInto: which is a hack but that is really fast. The problem is that #nextWordsInto: has to always do the #restoreEndianness when we are in little endian machines (most of the time).</h3><p>Hence, this cluster provives the best of both worlds: the serialization is done with a platform-dependen way, that is, the endianness will be the same of the machine where we are serializing. In addition, we serialize with the same hack that #nextWordsInto: uses, that is, the <a class="stClassLiteral" href="class/FLWordObjectCluster.html/class/Bitmap.html">Bitmap</a> &gt;&gt; hackBits: And the materialization will use a variation of #nextWordsInto:  (#fuelNextWordsInto:) that ONLY does the #restoreEndianness if the machine where we are materializing has a different endianness than where we have serialized the object. To do this, while serializing, we store in the header of the Fuel stream, the endianness. Then in materialization, we compare agains that. </p><p>Conclusion: we only restore endianness when needed.</p><p>Notice, in addition, that the method #newFromStream: sends the message #restoreEndianness. This method EXPECTS that the object was serialized in big endian format, and it will only change the endianness if we are materializing in a little endian machine. This means that if you serialize in little endian and materialize in big endian, you are screw.  For this reason, this cluster uses a method that always change the endianness, <a class="stClassLiteral" href="class/FLWordObjectCluster.html/class/Bitmap.html">Bitmap</a> class &gt;&gt; swapBytesIn:from:to: </p><p>Future work: maybe we can modify and use the <a class="stClassLiteral" href="class/FLWordObjectCluster.html/class/Bitmap.html">Bitmap</a> hackBits:   not only for materialization but also for serialization.</p></div></div><div class="instanceMethodDetail methodDetail"><h2 class="title">Instance Method Details</h2></div></div><script type="text/javascript">/*<![CDATA[*/function onLoad(){};/*]]>*/</script></body></html>